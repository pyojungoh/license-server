# 보안 개선 방안 - 토큰 인증 지속성 문제

## 🔍 현재 문제점

### 발견된 문제
사용자가 토큰을 받고 앱을 끈 후에도, 앱을 다시 켜지 않아도 프로그램이 계속 작동합니다.

### 원인 분석

1. **ESP32의 인증 상태가 영구적으로 유지됨**
   - ESP32는 토큰을 받으면 `isActivated = true`로 설정
   - 이 상태는 ESP32가 재부팅되거나 연결이 끊기기 전까지 유지됨
   - 앱이 꺼져도 ESP32의 `isActivated` 플래그는 그대로 유지

2. **BLE HID 연결과 GATT 연결의 독립성**
   - ESP32는 두 가지 연결을 동시에 유지:
     - **BLE HID 키보드 연결**: `bleKeyboard.isConnected()` - 모바일 기기와의 키보드 연결
     - **GATT 서비스 연결**: 토큰을 받기 위한 Custom Service 연결 (앱과의 통신)
   - 앱을 꺼도 BLE HID 키보드 연결은 유지됨 (페어링 상태)
   - 따라서 `bleKeyboard.isConnected()`는 여전히 `true`를 반환

3. **현재 코드의 동작**
   ```cpp
   if (isActivated && isConnected) {
       // 키보드 기능 동작
   }
   ```
   - `isActivated = true` (토큰 받음)
   - `isConnected = true` (BLE HID 키보드 연결 유지)
   - → 앱이 꺼져도 조건이 true로 유지되어 계속 작동

---

## ⚠️ 보안 문제점

### 문제 1: 무단 사용 가능
- 한 번 토큰을 받으면, 앱을 끈 후에도 계속 사용 가능
- 다른 사람이 내 기기를 사용할 수 있음 (토큰 만료 없음)

### 문제 2: 토큰 만료 검증 없음
- 현재는 토큰을 받기만 하면 계속 사용 가능
- 서버에서 토큰이 만료되었어도 ESP32는 알 수 없음

### 문제 3: 연결 해제 감지 부재
- 앱이 꺼져도 BLE HID 연결은 유지되므로 감지 불가
- GATT 연결 해제를 감지할 방법이 없음

---

## 💡 해결 방안

### 방안 1: 주기적 토큰 재검증 (권장)

**개념**: ESP32가 주기적으로 서버에 토큰을 재검증

**장점**:
- 서버의 토큰 만료 시간을 준수
- 토큰이 취소되어도 즉시 차단 가능

**단점**:
- ESP32에 WiFi 연결 필요 (현재는 없음)
- 구현 복잡도 증가

**구현**:
1. ESP32에 WiFi 기능 추가
2. 주기적으로 (예: 1분마다) 서버 API 호출
3. 토큰 검증 실패 시 `isActivated = false` 설정

---

### 방안 2: GATT 연결 상태 모니터링

**개념**: Custom BLE Service의 GATT 연결 상태를 감지하여 앱이 연결되어 있는지 확인

**장점**:
- WiFi 불필요
- 앱이 꺼지면 자동으로 비활성화

**단점**:
- BLE HID와 Custom Service의 연결이 독립적이어서 완벽하지 않을 수 있음
- 구현이 복잡할 수 있음

**구현**:
1. BLE Server의 연결 콜백에서 GATT 연결 상태 추적
2. 연결이 끊기면 `isActivated = false` 설정
3. 재연결 시 새 토큰 필요

---

### 방안 3: 시간 기반 토큰 만료 (간단한 해결)

**개념**: ESP32에서 토큰을 받은 후 일정 시간(예: 1시간) 후 자동으로 만료

**장점**:
- 구현이 가장 간단
- WiFi 불필요

**단점**:
- 서버의 실제 토큰 만료 시간과 동기화되지 않음
- 앱을 끈 후에도 지정된 시간 동안은 작동함

**구현**:
```cpp
unsigned long tokenExpiryTime = 0;
const unsigned long TOKEN_VALIDITY_MS = 3600000; // 1시간

void onTokenReceived(String token) {
    isActivated = true;
    tokenExpiryTime = millis() + TOKEN_VALIDITY_MS;
}

void loop() {
    // 토큰 만료 확인
    if (isActivated && millis() > tokenExpiryTime) {
        isActivated = false;
        digitalWrite(LED_PIN, LOW);
        Serial.println("⏰ 토큰 만료됨 (재인증 필요)");
    }
    
    if (isActivated && isConnected) {
        // 키보드 기능
    }
}
```

---

### 방안 4: 앱 생존 확인 (Heartbeat)

**개념**: 앱이 주기적으로 ESP32에 "살아있음" 신호를 보냄

**장점**:
- 앱이 꺼지면 즉시 감지 가능
- WiFi 불필요

**단점**:
- 앱에서 주기적으로 신호를 보내야 함 (배터리 소모)
- 구현 복잡도 증가

**구현**:
1. ESP32의 Characteristic에 Heartbeat 기능 추가
2. 앱에서 주기적으로 (예: 10초마다) Heartbeat 전송
3. 일정 시간(예: 30초) 동안 Heartbeat가 없으면 `isActivated = false`

---

## 🎯 권장 방안

### 단기 해결책: 방안 3 (시간 기반 만료)
- 구현이 가장 간단
- 즉시 적용 가능
- 기본적인 보안 제공

### 장기 해결책: 방안 1 (주기적 토큰 재검증)
- 가장 안전한 방법
- 서버의 토큰 관리와 완벽히 동기화
- WiFi 기능 추가 필요

---

## 📋 현재 상태 vs 개선 후

### 현재 상태
- ❌ 토큰을 받으면 영구적으로 작동
- ❌ 앱을 꺼도 계속 사용 가능
- ❌ 토큰 만료 검증 없음

### 방안 3 적용 후 (시간 기반)
- ✅ 토큰을 받은 후 일정 시간 후 자동 만료
- ⚠️ 앱을 꺼도 만료 시간까지는 작동 (하지만 시간 제한 있음)
- ✅ 기본적인 시간 기반 보안 제공

### 방안 1 적용 후 (재검증)
- ✅ 주기적으로 서버에서 토큰 재검증
- ✅ 서버 토큰 만료 시 즉시 차단
- ✅ 가장 안전한 방법

---

## 🔧 구현 예시 (방안 3: 시간 기반 만료)

```cpp
// 전역 변수 추가
unsigned long tokenReceivedTime = 0;
const unsigned long TOKEN_VALIDITY_MS = 3600000; // 1시간 (1000 * 60 * 60)

// 토큰 수신 시
void onTokenReceived(String token) {
    if (token.length() > 10) {
        isActivated = true;
        tokenReceivedTime = millis(); // 현재 시간 저장
        Serial.println("✓ 인증 성공! 키보드 기능 활성화됨 (1시간 유효)");
        digitalWrite(LED_PIN, HIGH);
    }
}

// loop() 함수에 추가
void loop() {
    // 토큰 만료 확인
    if (isActivated && (millis() - tokenReceivedTime > TOKEN_VALIDITY_MS)) {
        isActivated = false;
        digitalWrite(LED_PIN, LOW);
        Serial.println("⏰ 토큰 만료됨 (1시간 경과) - 앱에서 재인증 필요");
        tokenReceivedTime = 0;
    }
    
    // 나머지 코드...
}
```

---

## ✅ 다음 단계

1. **즉시 적용**: 방안 3 (시간 기반 만료) 구현
2. **향후 개선**: 방안 1 (주기적 토큰 재검증) 구현을 위한 WiFi 기능 추가 검토






